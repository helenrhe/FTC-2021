package org.firstinspires.ftc.teamcode.vision;

import android.graphics.Bitmap;
import com.acmerobotics.dashboard.FtcDashboard;
import com.acmerobotics.dashboard.config.Config;
import org.firstinspires.ftc.teamcode.subsystems.ElevatorSubsystem;
import org.opencv.core.*;
import org.opencv.features2d.Feature2D;
import org.opencv.features2d.Features2d;
import org.opencv.features2d.SimpleBlobDetector;
import org.opencv.features2d.SimpleBlobDetector_Params;
import org.opencv.imgproc.*;
import org.openftc.easyopencv.OpenCvPipeline;

import java.util.function.Consumer;
import java.util.stream.Collector;

/**
* GripPipeline class.
*
* <p>An OpenCV pipeline generated by GRIP.
*
* @author GRIP
*/
@Config
public class GripPipeline extends OpenCvPipeline {

	public static double R_MIN = 0;
	public static double R_MAX = 110;
	public static double G_MIN = 0;
	public static double G_MAX = 255;
	public static double B_MIN = 0;
	public static double B_MAX = 255;

	//Outputs
	private Mat rgbThresholdOutput = new Mat();
	private Mat cvErodeOutput = new Mat();
	private MatOfKeyPoint findBlobsOutput = new MatOfKeyPoint();

	private KeyPointConsumer onUpdatedData;

	public interface KeyPointConsumer {
		void onUpdatedData(Point point);
	}

	public GripPipeline(KeyPointConsumer onUpdatedData) {
		this.onUpdatedData = onUpdatedData;
	}

	/**
	 * This is the primary method that runs the entire pipeline and updates the outputs.
	 * @return
	 */
	public Mat processFrame(Mat source0) {
		// Step RGB_Threshold0:Mat
		Mat rgbThresholdInput = source0;
		double[] rgbThresholdRed = {R_MIN, R_MAX};
		double[] rgbThresholdGreen = {G_MIN, G_MAX};
		double[] rgbThresholdBlue = {B_MIN, B_MAX};
		rgbThreshold(rgbThresholdInput, rgbThresholdRed, rgbThresholdGreen, rgbThresholdBlue, rgbThresholdOutput);

		// Step Blur0:
		Mat cvErodeSrc = rgbThresholdOutput;
		Mat cvErodeKernel = new Mat();
		Point cvErodeAnchor = new Point(-1, -1);
		double cvErodeIterations = 2.0;
		int cvErodeBordertype = Core.BORDER_CONSTANT;
		Scalar cvErodeBordervalue = new Scalar(-1);
		cvErode(cvErodeSrc, cvErodeKernel, cvErodeAnchor, cvErodeIterations, cvErodeBordertype, cvErodeBordervalue, cvErodeOutput);

		// Step Find_Blobs0:
		Mat findBlobsInput = cvErodeOutput;
		double findBlobsMinArea = 0;
		double[] findBlobsCircularity = {0.0, 1.0};
		boolean findBlobsDarkBlobs = false;
		findBlobs(findBlobsInput, findBlobsMinArea, findBlobsCircularity, false, findBlobsOutput);


		float biggestSize = -1;
		Point biggestPoint = null;
		for(KeyPoint point : findBlobsOutput().toArray()) {
			if(point.size > biggestSize) {
				biggestSize = point.size;
				biggestPoint = point.pt;
			}
		}

		if(biggestPoint != null)
			onUpdatedData.onUpdatedData(biggestPoint);

		Mat out = new Mat();

		Features2d.drawKeypoints(cvErodeOutput, findBlobsOutput, out, new Scalar(0,0,255), Features2d.DrawMatchesFlags_DRAW_RICH_KEYPOINTS);

		return out;
	}

	private void saveBitmap(Bitmap bitmap, String name) {
//		File file = new File(AppUtil.ROBOT_DATA_DIR, String.format(Locale.getDefault(), name + ".jpg"));
//		AppUtil.getInstance().ensureDirectoryExists(AppUtil.ROBOT_DATA_DIR);
//
//		try {
//			try (FileOutputStream outputStream = new FileOutputStream(file)) {
//				bitmap.compress(Bitmap.CompressFormat.JPEG, 100, outputStream);
//			}
//		} catch (IOException e) {
//			e.printStackTrace();
//		}
		FtcDashboard.getInstance().sendImage(bitmap);
	}

	/**
	 * This method is a generated getter for the output of a RGB_Threshold.
	 * @return Mat output from RGB_Threshold.
	 */
	public Mat rgbThresholdOutput() {
		return rgbThresholdOutput;
	}

	/**
	 * This method is a generated getter for the output of a Blur.
	 * @return Mat output from Blur.
	 */
	public Mat blurOutput() {
		return cvErodeOutput;
	}

	/**
	 * This method is a generated getter for the output of a Find_Blobs.
	 * @return MatOfKeyPoint output from Find_Blobs.
	 */
	public MatOfKeyPoint findBlobsOutput() {
		return findBlobsOutput;
	}


	/**
	 * Segment an image based on color ranges.
	 * @param input The image on which to perform the RGB threshold.
	 * @param red The min and max red.
	 * @param green The min and max green.
	 * @param blue The min and max blue.
	 * @param out The image in which to store the output.
	 */
	private void rgbThreshold(Mat input, double[] red, double[] green, double[] blue,
		Mat out) {
		Imgproc.cvtColor(input, out, Imgproc.COLOR_BGR2RGB);
		Core.inRange(out, new Scalar(red[0], green[0], blue[0]),
			new Scalar(red[1], green[1], blue[1]), out);
	}

	/**
	 * An indication of which type of filter to use for a blur.
	 * Choices are BOX, GAUSSIAN, MEDIAN, and BILATERAL
	 */
	enum BlurType{
		BOX("Box Blur"), GAUSSIAN("Gaussian Blur"), MEDIAN("Median Filter"),
			BILATERAL("Bilateral Filter");

		private final String label;

		BlurType(String label) {
			this.label = label;
		}

		public static BlurType get(String type) {
			if (BILATERAL.label.equals(type)) {
				return BILATERAL;
			}
			else if (GAUSSIAN.label.equals(type)) {
			return GAUSSIAN;
			}
			else if (MEDIAN.label.equals(type)) {
				return MEDIAN;
			}
			else {
				return BOX;
			}
		}

		@Override
		public String toString() {
			return this.label;
		}
	}

	/**
	 * Softens an image using one of several filters.
	 * @param input The image on which to perform the blur.
	 * @param type The blurType to perform.
	 * @param doubleRadius The radius for the blur.
	 * @param output The image in which to store the output.
	 */
	private void blur(Mat input, BlurType type, double doubleRadius,
		Mat output) {
		int radius = (int)(doubleRadius + 0.5);
		int kernelSize;
		switch(type){
			case BOX:
				kernelSize = 2 * radius + 1;
				Imgproc.blur(input, output, new Size(kernelSize, kernelSize));
				break;
			case GAUSSIAN:
				kernelSize = 6 * radius + 1;
				Imgproc.GaussianBlur(input,output, new Size(kernelSize, kernelSize), radius);
				break;
			case MEDIAN:
				kernelSize = 2 * radius + 1;
				Imgproc.medianBlur(input, output, kernelSize);
				break;
			case BILATERAL:
				Imgproc.bilateralFilter(input, output, -1, radius, radius);
				break;
		}
	}

	/**
	 * Expands area of lower value in an image.
	 * @param src the Image to erode.
	 * @param kernel the kernel for erosion.
	 * @param anchor the center of the kernel.
	 * @param iterations the number of times to perform the erosion.
	 * @param borderType pixel extrapolation method.
	 * @param borderValue value to be used for a constant border.
	 * @param dst Output Image.
	 */
	private void cvErode(Mat src, Mat kernel, Point anchor, double iterations,
						 int borderType, Scalar borderValue, Mat dst) {
		if (kernel == null) {
			kernel = new Mat();
		}
		if (anchor == null) {
			anchor = new Point(-1,-1);
		}
		if (borderValue == null) {
			borderValue = new Scalar(-1);
		}
		Imgproc.erode(src, dst, kernel, anchor, (int)iterations, borderType, borderValue);
	}

	/**
	 * Detects groups of pixels in an image.
	 * @param input The image on which to perform the find blobs.
	 * @param minArea The minimum size of a blob that will be found
	 * @param circularity The minimum and maximum circularity of blobs that will be found
	 * @param darkBlobs The boolean that determines if light or dark blobs are found.
	 * @param blobList The output where the MatOfKeyPoint is stored.
	 */
	private void findBlobs(Mat input, double minArea, double[] circularity,
		Boolean darkBlobs, MatOfKeyPoint blobList) {
		SimpleBlobDetector_Params params = new SimpleBlobDetector_Params();

		params.set_thresholdStep(10);
		params.set_minThreshold(0);
		params.set_maxThreshold(220);
		params.set_minRepeatability(1);
		params.set_minDistBetweenBlobs(0);

		params.set_filterByArea(true);
		params.set_minArea((float) minArea);
		params.set_maxArea(Integer.MAX_VALUE);

		SimpleBlobDetector blobDet = SimpleBlobDetector.create(params);

		blobDet.detect(input, blobList);
	}




}

